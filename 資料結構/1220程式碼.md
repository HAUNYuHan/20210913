# äºŒå…ƒæœå°‹æ¨¹çš„ç¨‹å¼ç¢¼è¬›è§£(äºŒ)
```
//BST.h å®šç¾©ç¨‹å¼æœƒç”¨åˆ°çš„æ‰€æœ‰å‰¯ç¨‹å¼çš„å‹æ…‹
int Search(int*, int*);
struct TreeNode* CreateTree(struct TreeNode* , int*);
struct TreeNode* CreateNode(struct TreeNode*, int);
struct TreeNode* AddNode(struct TreeNode*, int);
struct TreeNode* ShowTree(struct TreeNode*);
int SearchNode(struct TreeNode*, int, int);
struct TreeNode* SearchTree(struct TreeNode*, int*);
```
```
//BST.CPP
#include "stdio.h"
#include "stdlib.h"
#include "time.h"
#include "BST.h"
struct TreeNode{ //å®£å‘Šç¯€é»çš„åç¨±èˆ‡çµæ§‹
struct TreeNode* pri=NULL; //æŒ‡å‘çˆ¶ç¯€é»çš„ä½å€é è¨­ç‚ºç©ºæŒ‡æ¨™
struct TreeNode* right=NULL; //æŒ‡å‘å³å­ç¯€é»çš„ä½å€é è¨­ç‚ºç©ºæŒ‡æ¨™
struct TreeNode* left=NULL; //æŒ‡å‘å·¦å­ç¯€é»çš„ä½å€é è¨­ç‚ºç©ºæŒ‡æ¨™
int data; //ç¯€é»çš„éµå€¼
};
static struct TreeNode* tree_header;
//å®£å‘Šéœæ…‹æŒ‡æ¨™ tree_header æŒ‡å‘æ ¹ç¯€é»çš„ä½å€
int main(){
int m,s=0,x=0,data_num=0;
int data1[60]; //å®£å‘Šæœ‰ 60 æ¬„ä½çš„æ•´æ•¸å‹æ…‹é™£åˆ— data1
int data2[10]; //å®£å‘Šæœ‰ 10 æ¬„ä½çš„æ•´æ•¸å‹æ…‹é™£åˆ— data2
for(int i=0; i<60; i++){ //å°‡ data1 çš„ 60 æ¬„ä½éƒ½æ¸…ç‚º 0
data1[i]=0;
}
for(int i=0; i<10; i++){ //å°‡ data2 çš„ 10 æ¬„ä½éƒ½æ¸…ç‚º 0
data2[i]=0;
}
//éš¨æ©Ÿç”¢ç”Ÿ 60 å€‹ 0 åˆ° 99 çš„ç›¸ç•°æ•´æ•¸,ä¸¦å°‡å…¶å­˜å…¥ data1 çš„ 60 æ¬„ä½ä¸­
for(int i=0;i<60 ;i++){
int m=0, n=1;
while(n==1){
n=0;
srand((unsigned)time(NULL));
m = (rand()*(rand()%10))%100;
// ä»¥æ™‚é–“åºåˆ—ç•¶äº‚æ•¸ç¨®å­ å– 0-99 çš„äº‚æ•¸
for(int j=0;j<i;j++){
if(m==data1[j]) n=1;
}
}
data1[i]=m;
}
//éš¨æ©Ÿç”¢ç”Ÿ 10 å€‹ 0 åˆ° 99 çš„ç›¸ç•°æ•´æ•¸,ä¸¦å°‡å…¶å­˜å…¥ data2 çš„ 10 æ¬„ä½ä¸­
for(int i=0;i<10 ;i++){
int m=0;
int n=1;
while(n==1){
n=0;
srand((unsigned)time(NULL)); // ä»¥æ™‚é–“åºåˆ—ç•¶äº‚æ•¸ç¨®å­
m=rand()%100;
for(int j=0;j<i;j++){
if(m==data2[j]) n=1;
}
}
data2[i]=m;
}
//é¡¯ç¤º data1 çš„ 60 æ¬„ä½çš„å€¼
printf("æœ‰ 60 ç­†è³‡æ–™å€¼\n");
for(int i=0;i<60 ;i++){
printf("%d, ", data1[i]);
}
printf("\n\n\n");
printf("æ‰¾å‡ºä¸‹åˆ— 10 ç­†è³‡æ–™æ˜¯å¦åœ¨ä¸Šé¢ 60 ç­†è³‡æ–™ä¸­\n");
//é¡¯ç¤º data2 çš„ 10 æ¬„ä½çš„å€¼
for(int i=0;i<10 ;i++){
printf("%d, ", data2[i]);
}
printf("\n\n\n");
printf("ä½¿ç”¨æš´åŠ›æ³•å°‹æ‰¾(ä¸€ç­†ä¸€ç­†æ‰¾):\n");
int total = Search(data1, data2); //ä½¿ç”¨æš´åŠ›æ³•å°‹æ‰¾
printf("\n");
total = total/10;
printf("å¹³å‡æ‰¾äº† %d æ¬¡\n", total);
printf("\n\n\n");
printf("ä½¿ç”¨äºŒå…ƒæœå°‹æ¨¹å°‹æ‰¾\n");
tree_header = CreateTree(tree_header, data1); //å»ºç«‹äºŒå…ƒæœå°‹æ¨¹
SearchTree(tree_header, data2); //ä½¿ç”¨äºŒå…ƒæœå°‹æ¨¹å°‹æ‰¾
return 0;
}
//ä½¿ç”¨æš´åŠ›æ³•å°‹æ‰¾, å³å¾ data1 ç¬¬ä¸€ç­†è³‡æ–™é–‹å§‹ä¸€ç­†ä¸€ç­†è³‡æ–™çš„å°‹æ‰¾
int Search(int data1[60], int data2[10]){
int total, index, p;
total = 0;
for(int i =0; i<10; i++){
index = 0;
p = 0;
for(int j = 0; j<60; j++){
index++;
if(data2[i]==data1[j]){
printf(" %d æ‰¾åˆ°äº†!!å…±æ‰¾äº† %d æ¬¡\n", data2[i], index);
p = 1;
break;
}
}
total = total + index;
if(p==0) printf(" %d æ²’æ‰¾åˆ°!!å…±æ‰¾äº† %d æ¬¡\n", data2[i], index);
}
return total;
}
```
## å»ºç«‹äºŒå…ƒæœå°‹æ¨¹
```
struct TreeNode* CreateTree(struct TreeNode* header, int data[60]){
header = CreateNode(header, data[0]);
//å»ºç«‹äºŒå…ƒæœå°‹æ¨¹çš„æ¨¹æ ¹ä¸¦å°‡ç¬¬ä¸€ç­†è³‡æ–™å­˜å…¥æ¨¹æ ¹ç¯€é»ä¸­
if(header == NULL) return NULL;
for(int i=1; i<60; i++){
AddNode(header, data[i]);
//ä¾åºå°‡ç¬¬ 2 ç­†åˆ°ç¬¬ 60 ç­†è³‡æ–™åŠ å…¥äºŒå…ƒæœå°‹æ¨¹ä¸­
}
return header;
}
```
## å»ºç«‹å»ºç«‹äºŒå…ƒæœå°‹æ¨¹çš„æ¨¹æ ¹
```
struct TreeNode* CreateNode(struct TreeNode* header, int value){
header = (struct TreeNode *)malloc(sizeof(struct TreeNode));
//é…ç½®è¨˜æ†¶é«”ç©ºé–“çµ¦ç¯€é», ä¸¦å°‡è¨˜æ†¶é«”ä½å€å‚³å›çµ¦ header æŒ‡æ¨™
if(header == NULL) return NULL; //è‹¥é…ç½®å¤±æ•— header å‚³å›ç©ºæŒ‡æ¨™
header->data = value; //å°‡å€¼æ”¾å…¥ç¯€é»çš„éµå€¼æ¬„ä½
header->pri = NULL; //ç¯€é»çš„çˆ¶ç¯€é»çš„ä½å€è¨­ç‚ºç©ºæŒ‡æ¨™
header->left = NULL; //ç¯€é»çš„å·¦å­ç¯€é»çš„ä½å€è¨­ç‚ºç©ºæŒ‡æ¨™
header->right = NULL; //ç¯€é»çš„å³å­ç¯€é»çš„ä½å€è¨­ç‚ºç©ºæŒ‡æ¨™
return header;
}
```
# äºŒå…ƒæœå°‹æ¨¹çš„ç¨‹å¼ç¢¼(äºŒ)
```
//BST.CPP
#include "stdio.h"
#include "stdlib.h"
#include "time.h"
#include "BST.h"
struct TreeNode{
struct TreeNode* pri=NULL;
struct TreeNode* right=NULL;
struct TreeNode* left=NULL;
int data;
};
static struct TreeNode* tree_header;
int main(){
int m,s=0,x=0,data_num=0;
int data1[60];
int data2[10];
for(int i=0; i<60; i++){
data1[i]=0;
}
for(int i=0; i<10; i++){
data2[i]=0;
}
for(int i=0;i<60 ;i++){
int m=0, n=1;
while(n==1){
n=0;
srand((unsigned)time(NULL));
m = (rand()*(rand()%10))%100;
// ä»¥æ™‚é–“åºåˆ—ç•¶äº‚æ•¸ç¨®å­ å– 0-99 çš„äº‚æ•¸
for(int j=0;j<i;j++){
if(m==data1[j]) n=1;
}
}
data1[i]=m;
}
for(int i=0;i<10 ;i++){
int m=0;
int n=1;
while(n==1){
n=0;
srand((unsigned)time(NULL)); // ä»¥æ™‚é–“åºåˆ—ç•¶äº‚æ•¸ç¨®å­
m=rand()%100;
for(int j=0;j<i;j++){
if(m==data2[j]) n=1;
}
}
data2[i]=m;
}
printf("æœ‰ 60 ç­†è³‡æ–™å€¼\n");
for(int i=0;i<60 ;i++){
printf("%d, ", data1[i]);
}
printf("\n\n\n");
printf("æ‰¾å‡ºä¸‹åˆ— 10 ç­†è³‡æ–™æ˜¯å¦åœ¨ä¸Šé¢ 60 ç­†è³‡æ–™ä¸­\n");
for(int i=0;i<10 ;i++){
printf("%d, ", data2[i]);
}
printf("\n\n\n");
printf("ä½¿ç”¨æš´åŠ›æ³•å°‹æ‰¾(ä¸€ç­†ä¸€ç­†æ‰¾):\n");
int total = Search(data1, data2);
printf("\n");
total = total/10;
printf("å¹³å‡æ‰¾äº† %d æ¬¡\n", total);
printf("\n\n\n");
printf("ä½¿ç”¨äºŒå…ƒæœå°‹æ¨¹å°‹æ‰¾\n");
tree_header = CreateTree(tree_header, data1);
SearchTree(tree_header, data2);
return 0;
}
int Search(int data1[60], int data2[10]){
int total, index, p;
total = 0;
for(int i =0; i<10; i++){
index = 0;
p = 0;
for(int j = 0; j<60; j++){
index++;
if(data2[i]==data1[j]){
printf(" %d æ‰¾åˆ°äº†!!å…±æ‰¾äº† %d æ¬¡\n", data2[i], index);
p = 1;
break;
}
}
total = total + index;
if(p==0) printf(" %d æ²’æ‰¾åˆ°!!å…±æ‰¾äº† %d æ¬¡\n", data2[i], index);
}
return total;
}
struct TreeNode* CreateTree(struct TreeNode* header, int data[60]){
header = CreateNode(header, data[0]);
if(header == NULL) return NULL;
for(int i=1; i<60; i++){
AddNode(header, data[i]);
}
return header;
}
struct TreeNode* CreateNode(struct TreeNode* header, int value){
header = (struct TreeNode *)malloc(sizeof(struct TreeNode));
if(header == NULL) return NULL;
header->data = value;
header->pri = NULL;
header->left = NULL;
header->right = NULL;
return header;
}
struct TreeNode* AddNode(struct TreeNode* header, int value){
struct TreeNode* current;
current = header;
if(value <= current->data){
if(current->left == NULL){
current->left = (struct TreeNode *)malloc(sizeof(struct TreeNode));
if(current->left == NULL) return NULL;
current->left->data=value;
current->left->left=NULL;
current->left->right=NULL;
current->left->pri=current;
}
else{
AddNode(current->left, value);
}
}
else if(value > current->data){
if(current->right == NULL){
current->right = (struct TreeNode *)malloc(sizeof(struct TreeNode));
if(current->right == NULL) return NULL;
current->right->data=value;
current->right->left=NULL;
current->right->right=NULL;
current->right->pri=current;
}
else{
AddNode(current->right, value);
}
}
return current;
}
struct TreeNode* SearchTree(struct TreeNode* tree_header, int data2[10]){
int index=0;
for (int i = 0; i <10; i++){
index = index + SearchNode(tree_header, data2[i], 0);
}
}
int SearchNode(struct TreeNode* tree_header, int value, int index){
if (tree_header == NULL){
index++;
printf(" %d æ²’æ‰¾åˆ°!!å…±æ‰¾äº† %d æ¬¡\n", value, index);
return index;
}
else if (tree_header->data == value){
index++;
printf(" %d æ‰¾åˆ°äº†!!å…±æ‰¾äº† %d æ¬¡\n", value, index);
return index;
}
else if (tree_header->data > value){
index++;
return SearchNode(tree_header->left, value, index);
}
else if (tree_header->data < value){
index++;
return SearchNode(tree_header->right, value, index);
}
}
```
# å¿«é€Ÿæ’åºæ³• (Quick Sort)
```
å°‡ä¸€å€‹æ•¸åˆ—çš„æ•¸å¾å°åˆ°å¤§åšæ’åˆ—çš„æ–¹æ³•
```
### å„ªé»:
```
æ¼”ç®—æ³•è¤‡é›œåº¦ä½(n log2 ğ‘›), èƒ½å¿«é€Ÿå®Œæˆæ’åˆ—
æ–¹æ³•:
1. ç¢ºå®šæ•¸åˆ—ä¸­æœ€å¾Œä¸€å€‹æ•¸åœ¨æ’åºçš„ä½ç½®
2. å°‡ä½ç½®ä¹‹å‰çš„æ•¸ä»¥åŠä½ç½®ä¹‹å¾Œçš„æ•¸å†åšå¿«é€Ÿæ’åº
3. ç›´åˆ°æ²’æœ‰æ•¸ç‚ºæ­¢
```
### èªªæ˜:
```
ç¢ºå®šæ•¸åˆ—ä¸­æœ€å¾Œä¸€å€‹æ•¸åœ¨æ’åºçš„ä½ç½®
ä»¥æœ€å¾Œä¸€å€‹æ•¸ç‚ºåŸºæº–æ•¸, åœ¨æ•¸åˆ—ä¸­æ¯”åŸºæº–æ•¸å¤§çš„æ•¸æ¬åˆ°åŸºæº–æ•¸çš„å¾Œé¢, åœ¨æ•¸åˆ—ä¸­
æ¯”åŸºæº–æ•¸å°çš„æ•¸æ¬åˆ°åŸºæº–æ•¸çš„å‰é¢
```
