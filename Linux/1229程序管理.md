```
每個程序有獨自的PID
```
```
原本運作的bash就是父程序
被父程序觸發的另一個bash就是子程序
```
```
fork and exec:程序呼叫的流程
```
```
ps -l
● F:代表這個程序旗標 (process flags)，說明這個程序的總結權限

常見號碼有：
● 若為 4 表示此程序的權限為 root
● 若為 1 則表示此子程序僅進行複製(fork)而沒有實際執行(exec)

● S：代表這個程序的狀態 (STAT)
主要的狀態有：
● R(Running)：該程式正在運作中；
● S(Sleep)：該程式目前正在睡眠狀態(idle)，但可以被喚醒(signal)。
● D：不可被喚醒的睡眠狀態，通常這支程式可能在等待 I/O 的情況(例如列印)
● T：停止狀態(stop)，可能是在工作控制(背景暫停)或除錯 (traced)狀態；
● Z(Zombie)：僵屍狀態，程序已經終止但卻無法被移除至記憶體外。
● UID/PID/PPID：代表『此程序被該 UID 所擁有/程序的 PID 號碼/此程序的父程序 PID 號碼』
● C：代表 CPU 使用率，單位為百分比；
● PRI/NI：Priority/Nice 的縮寫，代表此程序被 CPU 所執行的優先順序，數值越小代表該程序越快被 CPU 執行。
● ADDR/SZ/WCHAN：都與記憶體有關，ADDR 是 kernel function，指出該程序在記憶體的哪個部分，
如果是個 running 的程序，一般就會顯示『 - 』 / SZ 代表此程序用掉多少記憶體 / WCHAN 表示目前程序是否運作中，
同樣的， 若為 - 表示正在運作中。
● TTY：登入者的終端機位置，若為遠端登入則使用動態終端介面 (pts/n)；
● TIME：使用掉的 CPU 時間，注意，是此程序實際花費 CPU 運作的時間，而不是系統時間；
● CMD：就是 command 的縮寫，造成此程序的觸發程式之指令為何。
```
```
ps aux
> 你會發現 ps -l 與 ps aux 顯示的項目並不相同！
● USER:該 process 屬於那個使用者帳號的？
● PID ：該 process 的程序識別碼。
● %CPU：該 process 使用掉的 CPU 資源百分比；
● %MEM：該 process 所佔用的實體記憶體百分比；
● VSZ ：該 process 使用掉的虛擬記憶體量 (Kbytes)
● RSS ：該 process 佔用的固定的記憶體量 (Kbytes)
● TTY ：該 process 是在那個終端機上面運作，若與終端機無關則顯示 ?，
另外， tty1-tty6 是本機上面的登入者程序，若為 pts/0 等等的，則表示為由網路連接進主機的程序。
● STAT：該程序目前的狀態，狀態顯示與 ps -l 的 S 旗標相同 (R/S/T/Z)
● START：該 process 被觸發啟動的時間；
● TIME ：該 process 實際使用 CPU 運作的時間。
● COMMAND：該程序的實際指令為何？
```
```
ps -lA
> 每個欄位與 ps -l 的輸出情況相同，但顯示的程序則包括系統所有的程序。
```
```
ps axjf
> 類似樹狀架構的關聯
> 這是以ssh網路連線進虛擬機來測試的，程序之間是有相關性的。
```
### 僵屍 (zombie)
```
> 造成僵屍程序的成因是因為該程序應該已經執行完畢，或者是因故應該要終止了，
但是該程序的父程序卻無法完整的將該程序結束掉，而造成那個程序一直存在記憶體當中。

> 後面還接上 <defunct> 時，就代表該程序是僵屍程序，
例如：
apache  8683  0.0  0.9 83384 9992 ?   Z  14:33   0:00 /usr/sbin/httpd <defunct>
```
## top：動態觀察程序的變化
```
> top [-d 數字] | top [-bnp]
● -d：後面接秒數，就是整個程序畫面更新的秒數。預設是5秒；
● -b：以批次的方式執行 top ，還有更多的參數可以使用喔！
      通常會搭配資料流重導向來將批次的結果輸出成為檔案。
● -n：與 -b 搭配，意義是，需要進行幾次 top 的輸出結果。
● -p：指定某些個 PID 來進行觀察監測而已。

> 在 top 執行過程當中可以使用的按鍵指令：
● ? ：顯示在 top 當中可以輸入的按鍵指令；
● P ：以 CPU 的使用資源排序顯示；
● M ：以 Memory 的使用資源排序顯示；
● N ：以 PID 來排序喔！
● T ：由該 Process 使用的 CPU 時間累積 (TIME+) 排序。
● k ：給予某個 PID 一個訊號  (signal)
● r ：給予某個 PID 重新制訂一個 nice 值。
● q ：離開 top 軟體的按鍵。
```
```
● PID ：每個 process 的 ID ；
● USER：該 process 所屬的使用者；
● PR ：Priority 的簡寫，程序的優先執行順序，越小越早被執行；
● NI ：Nice 的簡寫，與 Priority 有關，也是越小越早被執行；
● %CPU：CPU 的使用率；
● %MEM：記憶體的使用率；
● TIME+：CPU 使用時間的累加；

● top 預設使用 CPU 使用率 (%CPU) 作為排序的重點
● 如果想要以記憶體使用率排序，則可以按下『m』
● 若要回復則按下『p』即可。
● 如果想要離開 top 則按下『 q 』吧！
```
### pstree指令
```
> pstree [-A|U] [-up]
● -A  ：各程序樹之間的連接以 ASCII 字元來連接；
● -U  ：各程序樹之間的連接以萬國碼的字元來連接。
      在某些終端介面下可能會有錯誤；
● -p  ：並同時列出每個 process 的 PID；
● -u  ：並同時列出每個 process 的所屬帳號名稱。

> pstree：列出目前系統上面所有的程序樹的相關性
```
### kill:給予程序一個訊號 (signal)
```
> kill -訊號代號 PID
```
| 代號 | 名稱 | 內容|
| --- | ---| ---|
| 1 | SIGHUP | 啟動被終止的程序，可讓該 PID 重新讀取自己的設定檔，類似重新啟動 |
| 2 | SIGINT |相當於用鍵盤輸入 [ctrl]-c 來中斷一個程序的進行 |
| 9 |SIGKILL | 代表強制中斷一個程序的進行，如果該程序進行到一半， 那麼尚未完成的部分可能會有『半產品』產生，類似 vim會有 .filename.swp 保留下來。 |
| 15 | SIGTERM | 以正常的結束程序來終止該程序。由於是正常的終止， 所以後續的動作會將他完成。不過，如果該程序已經發生問題，就是無法使用正常的方法終止時， 輸入這個 signal 也是沒有用的。 |
| 19 | SIGSTOP | 相當於用鍵盤輸入 [ctrl]-z 來暫停一個程序的進行 |

```
> killall [-iIe] [command name]

選項與參數：
● -i  ：interactive 的意思，互動式的，若需要刪除時，會出現提示字元給使用者；
● -e  ：exact 的意思，表示『後面接的 command name 要一致』，但整個完整的指令
      不能超過 15 個字元。
● -I  ：指令名稱(可能含參數)忽略大小寫。
```
```
● nice：新執行的指令即給予新的 nice 值
> nice [-n 數字] command
● -n  ：後面接一個數值，讓原本的 nice 加上這個新的數值之意。修改後的最終數值的範圍為 -20 ~ 19。

● renice：已存在程序的 nice 重新調整
> renice [number] PID
```
## 系統資源的觀察
```
● free ：觀察記憶體使用情況
● uname：查閱系統與核心相關資訊
● uptime：觀察系統啟動時間與工作負載
● netstat ：追蹤網路或插槽檔
● dmesg ：分析核心產生的訊息
● vmstat ：偵測系統資源變化
```
### free ：觀察記憶體使用情況
```
> free [-b|-k|-m|-g|-h] [-t] [-s N -c N]
選項與參數：
● -b  ：直接輸入 free 時，顯示的單位是 Kbytes，我們可以使用 b(bytes), m(Mbytes)
      k(Kbytes), 及 g(Gbytes) 來顯示單位喔！也可以直接讓系統自己指定單位 (-h)
● -t  ：在輸出的最終結果，顯示實體記憶體與 swap 的總量。
● -s  ：可以讓系統每幾秒鐘輸出一次，不間斷的一直輸出的意思！對於系統觀察挺有效！
● -c  ：與 -s 同時處理～讓 free 列出幾次的意思～
```
### uname：查閱系統與核心相關資訊
```
> uname [-asrmpi]
選項與參數：
● -a  ：所有系統相關的資訊，包括底下的資料都會被列出來；
● -s  ：系統核心名稱
● -r  ：核心的版本
● -m  ：本系統的硬體名稱，例如 i686 或 x86_64 等；
● -p  ：CPU 的類型，與 -m 類似，只是顯示的是 CPU 的類型！
● -i  ：硬體的平台 (ix86)
```
### uptime：觀察系統啟動時間與工作負載
```
● 顯示出目前系統已經開機多久的時間，以及 1, 5, 15 分鐘的平均負載。
```
### netstat：追蹤網路或插槽(socket)檔
```
● netstat 的輸出分為兩大部分:網路與系統自己的程序相關性部分
> netstat -[atunlp]
選項與參數：
● -a  ：將目前系統上所有的連線、監聽、Socket 資料都列出來
● -t  ：列出 tcp 網路封包的資料
● -u  ：列出 udp 網路封包的資料
● -n  ：不以程序的服務名稱，以埠號 (port number) 來顯示；
● -l  ：列出目前正在網路監聽 (listen) 的服務；
● -p  ：列出該網路服務的程序 PID
```
### vmstat ：偵測系統資源變化
```
選項與參數：
● -a  ：使用 inactive/active(活躍與否) 取代 buffer/cache 的記憶體輸出資訊；
● -f  ：開機到目前為止，系統複製 (fork) 的程序數；
● -s  ：將一些事件 (開機至目前為止) 導致的記憶體變化情況列表說明；
● -S  ：後面可以接單位，讓顯示的資料有單位。例如 K/M 取代 bytes 的容量；
● -d  ：列出磁碟的讀寫總量統計表
● -p  ：後面列出分割槽，可顯示該分割槽的讀寫總量統計表

程序欄位 (procs) 的項目分別為：
r：等待運作中的程序數量；
b：不可被喚醒的程序數量。
```
## fuser：藉由檔案(或檔案系統)找出正在使用該檔案的程序
```
> fuser [-umv] [-k [i] [-signal]] file/dir

選項與參數：
● -u  ：除了程序的 PID 之外，同時列出該程序的擁有者；
● -m  ：後面接的那個檔名會主動的上提到該檔案系統的最頂層，對 umount 不成功很有效！
● -v  ：可以列出每個檔案與程序還有指令的完整相關性！
● -k  ：找出使用該檔案/目錄的 PID ，並試圖以 SIGKILL 這個訊號給予該 PID；
● -i  ：必須與 -k 配合，在刪除 PID 之前會先詢問使用者意願！
● -signal：例如 -1 -15 等等，若不加的話，預設是 SIGKILL (-9) 囉！

c ：此程序在當前的目錄下(非次目錄)；
e ：可被觸發為執行狀態；
f ：是一個被開啟的檔案；
r ：代表頂層目錄 (root directory)；
F ：該檔案被開啟了，不過在等待回應中；
m ：可能為分享的動態函式庫

> 刪除
fuser -mki /home

```
